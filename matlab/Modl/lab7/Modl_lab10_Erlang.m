function note = Modl_lab10_Erlang(niterations)

if(nargin<1)
    niterations = 500; % дефолтное значение
end
t = zeros(1,niterations); % моменты времени
queued = zeros(1,niterations); % длина очереди в моменты времени

% mean service time
% = среднее время обслуживания
mst = 1/0.95; % 1/(интенсивность обслуживания)
lambda = 1.0; % интенсивность поступления требований

% начальное состояние СМО - в обслуживающем устройстве есть требование, а
% очередь пустая.

% код для вычисления времени до прихода следующего требования
k=4; % порядок потока Эрланга
kk=k-1; % коэф для ускорения расчетов
kle = (lambda.^k)./factorial(kk); % коэф для ускорения расчетов
% функция плотности распределения длительности промежутков времени между событиями 
f = @(t) kle.*exp(-lambda.*t).*(t.^kk); %

num=rand(); % случайная величина из равномерного распределения 0-1
req_in = fzero(@(tau) integral(f,0,tau)-num,[0,1000]); % получение случайной величины
% с разрешением уравнения (3.28 учебного пособия) с интегралом
queue=random('exp',mst); % очередь требований, голова которой находится уже в устройстве
abs_time=0.; % переменная для текущего момента времени
% шаг времени - минимум из оставшейся обработки требования в устройстве и
% оставшегося промежутка до прихода нового требования
[time_step,ind] = min([req_in, queue]); 
to_add = ind==1; % переключатель для прихода требования в нужный момент
req_in=req_in-time_step;
queue=queue-time_step;

for iter=2:niterations
    abs_time=abs_time+time_step; % текущее время с начала моделирования
    t(iter)=abs_time; % заносим запись
    if to_add
%    если должно прийти требование - разыгрываем для него время обработки
%    и добавляем в очередь. А также вычисляем новый промежуток до
%    следующего прихода.
        to_add=false;
        queue(end+1)=random('exp',mst);
        num=rand();
        req_in = fzero(@(tau) integral(f,0,tau)-num,[0,1000]);
    end
    if queue(1)==0
%    если голове очереди, то есть требованию, находящемуся в устройстве,
%    осталось до конца обработки 0 сек, то оно обработано, и надо
%    переместить на его место ближайшее из очереди.
        queue=queue(2:end);
    end
    if isempty(queue)
%    если в системе нет требований, остается только прождать до прихода
%    нового.
        time_step=req_in;
        to_add=true;
    elseif queue(1)>=req_in
%     если оставшаяся обработка закончится не раньше, чем придет новое
%     требование, то ждать будем именно прихода. Сделаем поправку для
%     оставшегося времени обработки.
        time_step=req_in;
        to_add=true;
        queue(1)=queue(1)-req_in;
    else
%     если оставшаяся обработка закончится раньше, чем придет новое
%     требование, то ждать будем конца обработки. Сделаем поправку для
%     оставшегося времени ожидания прихода требования.
        time_step=queue(1);
        queue(1)=0;
        req_in=req_in-time_step;
    end
    queued(iter) = length(queue(2:end)); % запись о длине очереи в этот момент
end
figure(3)
note = timeseries(queued,t); % объединили два массива в один объект.
plot(note)
end